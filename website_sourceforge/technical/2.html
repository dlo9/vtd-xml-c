<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<title>VTD-XML technical</title>
</head>

<body>

<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="1130" id="AutoNumber1" height="91">
  <tr>
    <td width="65%" height="1"><font face="Verdana" size="6">&nbsp;</font><b><font face="Tahoma" size="6">VTD-XML: 
    The Future of XML Processing</font></b></td>
    <td width="202%" height="1"><p align="center"><a href="http://sourceforge.net">
      <img src="https://sourceforge.net/sflogo.php?type=16&group_id=110612"
        width="210" height="62" border="0" alt="SourceForge.net Logo"></a></td>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="1130" id="AutoNumber2" height="23">
  <tr>
    <td width="23%" height="23" bgcolor="#000066"></td>
    <td width="23%" height="23" bgcolor="#000066">
    <p align="center">
    <a href="http://www.sf.net/projects/vtd-xml" style="text-decoration: none">
    <font size="2" face="Arial Black" color="#FFFFFF">Sourceforge Home</font></a></p>
    </td>
    <td width="17%" height="23" bgcolor="#000066">
    <p align="center"><font face="Arial Black" size="2" color="#FFFFFF">
    <a href="http://sourceforge.net/mail/?group_id=110612" style="text-decoration: none">
    Mailing Lists</a></font></td>
    <td width="17%" height="23" bgcolor="#000066">
    <p align="center"><font face="Arial Black">
    <a href="http://www.ximpleware.com/" style="text-decoration: none"><font color="#FFFFFF" size="2">XimpleWare</font></a></font></td>
    <td width="16%" height="23" bgcolor="#000066">
    <p align="center"><font face="Arial Black">
      <a href="http://sourceforge.net/project/showfiles.php?group_id=110612" style="text-decoration: none">
    <font color="#FFFFFF" size="2">Download</font></a></font></td>
    <td width="21%" height="23" bgcolor="#000066">
    </td>
  </tr>
</table>
<hr>
<table border="0" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="1130" id="AutoNumber3" height="3778">
  <tr>
    <td width="259" height="27" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net" style="text-decoration: none">VTD-XML Home</a></font></b></p>
    </blockquote>
    </td>
    <td height="3710" rowspan="14" valign="top" width="874" bgcolor="#E1E2D6">
    <blockquote>
      <h2 align="justify">&nbsp;</h2>
      <h2 align="justify"><font face="Lucida Sans" color="#25461C">2. A Processing 
      Model Based on VTD</font></h2>
      <p align="justify"><font face="Lucida Sans">Similar in many ways to 
      how DOM processes XML, our processing model first generates in-memory data 
      representation of XML, then exports it to calling applications through a 
      cursor-based navigation API. To help illustrate different components of 
      the data representation, we further divide the first step into <b>(1)</b> 
      &quot;non-extractive&quot; tokenization using <i>Virtual Token Descriptor (VTD)</i>
      <b>(2)</b> building hierarchical element directories using <i>Location 
      Cache (LC)</i>.<br>
      <br>
      In the rest of this section, we introduce the concept of each component, 
      and then describe some properties of the processing model.</font></p>
      <h3 align="justify"><font face="Lucida Sans" color="#25461C"><b>2.1 </b>
      <span style="font-weight: 400">A Quick Overview Virtual Token Descriptor 
      and Location Cache</span></font></h3>
      <p align="justify"><font face="Lucida Sans">While a tokenization 
      approach using offset/length is adequate for processing unstructured text 
      files, one needs additional information to describe a token in an XML 
      file. This has led to XimpleWare's design of VTD (Virtual Token 
      Descriptor). Unlike DOM or SAX, VTD is not an API specification; it is 
      instead a binary format specifying how to encode various parameters of a 
      token. A VTD record is a primitive data type that encodes the starting 
      offset, length, type and nesting depth of a token in XML. For certain 
      token types, we further split the length field into prefix length and 
      qualified name length since both share the same starting offset. VTD 
      records are usually stored in chunk-based buffer in the same order as they 
      appear in the document. In addition, the processing model built on top of 
      VTD mandates that one maintain the original document intact in memory.<br>
      <br>
      Specific to our current implementation, a VTD record is a 64-bit integer 
      in network byte order (big endian) with the following bit-level layout:</font></p>
      <ul>
        <li>
      <p align="justify"><font face="Lucida Sans"><b>Starting offset</b>- 
      30 bits (b29 ~ b0) </font></li>
      <li>
      <p align="justify"><font face="Lucida Sans"><b>Length</b>-20 bits 
      (b51 ~ b32) </font></li>
    <li>
      <p align="justify"><font face="Lucida Sans">For some token types
      </font>
    <ul>
      <li>
      <p align="justify"><font face="Lucida Sans"><b>Prefix length</b>: 9 
      bits (b51~ b43)</font></li>
    <li>
      <p align="justify"><font face="Lucida Sans"><b>Qname length</b>: 11 
      bits (b42 ~ b 32)</font></li>
  </ul>
  </li>
  <li>
      <p align="justify"><font face="Lucida Sans"><b>Nesting Depth</b>-8 
      bits (b59~b52) -- Maximum value is 2^8-2 = 254</font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Token type</b>-4 bits 
      (b63~b60) </font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Reserved bit</b>-2 
      bits (b31: b30) are reserved for a tri-state variable marking namespaces.</font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Unit</b>--Because the 
      processing model doesn't decode XML, the unit for offset and length are in 
      raw character of the transformation format. For UTF-8 and ISO-8859, length 
      and offset are in bytes. They are in 16-bit words for UTF-16. <b>Fig. 1</b> 
      depicts the bit-level layout of a VTD record.</font></li>
</ul>
<p align="center">
<font face="Lucida Sans">
<img border="0" src="2.html1.gif" width="711" height="314"></font></p>
<p align="center">
<b><font face="Lucida Sans" size="2">Fig. 1&nbsp; </font>
      <font face="Lucida Sans"><span style="font-size: 10.0pt; font-family: Times">
      Bit-level layout of a VTD record.</span></font></b></p>
      <p class="MsoNormal" style="text-indent:0in">
      <font face="Lucida Sans">To create a hierarchical view of XML, we 
      collect addresses of elements (i.e. VTD records for starting tags) into 
      chunk-based structures we call Location Caches (LCs). Location caches are 
      allocated on a per-level basis; i.e., the same LC indexes all elements of 
      the same depth. Similar to a VTD record, a LC entry is also a big-endian 
      64-bit integer. It upper 32 bits contain the address of the VTD record. 
      The lower 32 bits point to the LC entry corresponding to the first child 
      element. If there is no child element, the lower 32 bits are marked with 
      -1 (0xffff ffff).</font></p>
<p class="MsoNormal" style="text-indent:0in"><font face="Lucida Sans">At 
the top level, the parsed representation consists of the components shown in <b>
Fig. 2</b> after the parser finishes processing XML. Notice that, in addition to 
aforementioned components, we also include RI, the address of the root element, 
which doesn't change once those components have been generated. The same applies 
to M, the maximum depth of the document, which determines the size context 
object (discussed in Section 3) for subsequent navigation purposes.</font></p>
      <h3 align="justify">&nbsp;</h3>
      <h3 align="justify"><font face="Lucida Sans" color="#25461C">2.2
      <span style="font-weight: 400">Location Cache Lookup</span></font></h3>
      <p align="justify"><font face="Lucida Sans">At the top level, the LCs 
      are essentially hierarchical element directories of XML. The upper 32 bits 
      of an LC entry convey the &quot;directory&quot; aspect of LC as they explicitly 
      associate an LC entry with an element. The lower 32 bits, on the other 
      hand, convey the &quot;hierarchy&quot; aspect as they bind the LC entry with the one 
      corresponding to its first child element. To look up the VTD index of a 
      child element in LCs, one usually goes through the following steps: <b>(1)</b> 
      Record the LC entry of the first child. <b>(2)</b> Calculate and record 
      the LC entry of the last child. <b>(3)</b> If the lookup is to find the 
      first child, move the &quot;current&quot; LC entry over to point to the first child.
      <b>Fig. 3</b> illustrates various values and locations recorded after the 
      lookup for the first child element. Notice that the new location of 
      current entry is colored in red in <b>Fig. 3</b>.<br>
      &nbsp;</font></p>
      <p align="center">
      <font face="Lucida Sans">
      <img border="0" src="2.html2.jpg" width="659" height="444"><br clear="ALL">
      </font>
      <b><font face="Lucida Sans" size="2">Fig. 2&nbsp; Parsed 
      Representation of XML.</font></b></p>
      <p align="justify"><font face="Lucida Sans">For the second step 
      above, the LC entry of the last child is calculated as follows: <b>(1)</b> 
      Find the &quot;child-ful&quot; LC entry immediately after the current one. <b>(2)</b> 
      Retrieve the lower 32 bits of that entry (k). <b>(3)</b> The LC entry of 
      the last child is the one immediately before k. Notice that, in <b>Fig. 3</b>, 
      the entry immediately after the current one is skipped because it is 
      childless (marked by X).</font></p>
      <p align="justify"><font face="Lucida Sans">After those lookup steps, 
      one can be sure that the segment of the LC entries delimited by the first 
      and last child covers every child element of the current LC entry. If the 
      next lookup is to find the next sibling, one simply move the current entry 
      down one unit, the use the upper 32 bits to locate the corresponding VTD 
      record.</font></p>
      <p align="center">
      <font face="Lucida Sans">
      <img border="0" src="2.html3.jpg" width="575" height="403"><br clear="ALL">
      </font>
      <b><font face="Lucida Sans" size="2">Fig. 3. Resolving child 
      elements using Location Cache.</font></b></p>
      <h3 align="justify"><font face="Lucida Sans" color="#25461C">2.3 Properties of 
      the Processing Model</font></h3>
      <p align="justify"><font face="Lucida Sans">We highlight some of the 
      noteworthy properties of the processing model.</font></p>
      <ul>
        <li>
      <p align="justify"><font face="Lucida Sans"><b>Keep XML intact in 
      memory</b>-As the parsed state of XML, VTD records per se don't carry much 
      meaning; they only become meaningful when used alongside of the source XML 
      document. VTD records describe the structure of XML and provide access to 
      the token contents. If the application needs those tokens, it still has to 
      pick them up from the &quot;bucket.&quot; </font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Use integers, not 
      objects</b>- The parsed representation of XML makes extensive use of 
      64-bit integers at the lowest granularity level. Both LC and VTD use 
      64-bit integers as basic information storage units. This has both pros and 
      cons. A noticeable con: A VTD record doesn't have member methods. One of 
      the pros is that it is platform independent: Architecture-specific 
      implementations must explicitly conform to binary specifications all the 
      way down to bit-level layout.</font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Compact encoding</b>- 
      Both VTD and LC strive to squeeze maximum amount of information into every 
      record/entry. Without either one of those four parameters (offset, length, 
      type and depth), a VTD record becomes far less effective in describing 
      tokens of XML for subsequent navigation purposes. In some cases, a single 
      VTD record describes up to two tokens (the prefix length and qualified 
      name length). For a LC entry, the lower 32 bits point to the first child 
      element. The last child is inferred from another entry (usually the one 
      right after) of the same LC.</font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Constant record/entry 
      length</b>- In a linked list, individual members are associated with each 
      other by the explicit use of pointers. Those members must have pointer 
      fields defined as the instance variables. Because VTD records and LC 
      entries are equal in length (64-bit), when stored in chunk-based buffers, 
      related records/entries are associated with each other by <u> <i>natural 
      adjacency</i></u>. For example, an element token is usually near its 
      attributes. Also the next sibling, if there is one, is always immediately 
      after the current LC entry.</font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Addressable using 
      integers</b>- As a basic requirement, one should be able to address a 
      token/entry after parsing, e.g. to build a hierarchy. VTD records, when 
      stored in chunk-based buffers, can be addressed using indexes (integers). 
      This is different from extractive tokens, which can only be addressed by 
      pointers. As a result, many functions/methods in the navigation API 
      returns an integer that addresses a VTD record (-1 if no such record).</font></li>
<li>
      <p align="justify"><font face="Lucida Sans"><b>Element-based 
      Hierarchy</b>- Unlike DOM, which treats many node types as parts of the 
      hierarchy, the processing model builds hierarchy <i>for elements only</i>. 
      VTD's natural adjacency allows one to locate other &quot;leaf&quot; tokens, e.g. 
      attributes or text nodes, via direct searches in the vicinity of element 
      tokens. For mixed-content XML, LC entries provide additional hints for 
      possible locations of &quot;free-form&quot; text nodes.</font></li>
</ul>
      <p align="justify"><font face="Lucida Sans">In addition, there are 
      some practical considerations concerning the layout of a VTD record. 
      First, both prefixes and qualified names for starting tags and attribute 
      names usually are not very long. The maximum allowed lengths, 2048 (11 
      bits) for qualified name and 512 (9 bits) for prefix, should be 
      sufficiently for any practical uses. Additionally, we try to be 
      conservative in our choice of encoding the nesting depth in an 8-bit field 
      (up to 256 levels). Most of files we have come across, especially large 
      ones, are usually more flat than deep. Our VTD parser throws an exception 
      if there is an overflow condition for the prefix length, the qualified 
      name length or the depth of a token. For other token types, such as 
      <i>character data</i>, <i>CDATA</i> and <i>comment</i>, the VTD parser can potentially handle 
      length overflow by using multiple VTD records to represent a single XML 
      token.</font></p>
      <h3 align="justify"><font face="Lucida Sans" size="2"><br>
      </font><font face="Lucida Sans" color="#25461C">2.4 Memory Usage Estimation</font></h3>
      <p align="justify"><font face="Lucida Sans">We would like to make two 
      assumptions before estimating the total memory usage. First, we assume 
      that every starting tag has a matching ending tag. Secondly, VTD records 
      for ending tags are discarded because they carry little structural 
      significance. If there are a total of <i>n1</i> tokens (including ending 
      tags) and <i>n2</i> elements (starting tags) in a document of size (in 
      bytes) s, the total size of VTD records in bytes (without ending tags) is
      <i>(n1 - n2) x8</i> and the total size of LCs (totally indexed, i.e. one 
      LC entry per element) is n2x8. The sum of all those components is: <i>(</i>s 
      + 8x(n1-n2) + 8xn2) = s + 8xn1. <br>
      <br>
      As we can see from the calculation, the memory usage is a strong function 
      of the token &quot;intensity&quot; of XML, and basically not affected by the 
      structural complexity of the document. For document-oriented XML files 
      that have lots of text, e.g. a novel, our experience has been that the 
      memory usage is around 1.3 times the size of the document (assuming UTF-8 
      encoding). For data-oriented XML documents, the multiply factor is 
      typically around <i> <b>1.5~2</b></i>.</font><font face="Book Antiqua"><br>
&nbsp;</font></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="16" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/VTD.html" style="text-decoration: none">
      VTD in 30 seconds</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="15" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/persistence.html" style="text-decoration: none">VTD+XML Format</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="16" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/userGuide/0.html" style="text-decoration: none">User's Guide</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="16" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/DevGuide/0.html" style="text-decoration: none">Developer's Guide</a></font></b></p>
      </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="1" align="left" bordercolor="#0000FF" valign="top" bgcolor="#E1E2D6">
    <blockquote>
      <p><b><font face="Tahoma" size="1">VTD: A Technical Perspective</font></b></p>
      <p><b><font face="Tahoma" size="1">&nbsp;
      <a href="http://vtd-xml.sf.net/technical/0.html" style="text-decoration: none">0. Abstract</a></font></b></p>
      <p><b><font face="Tahoma" size="1">&nbsp;
      <a href="http://vtd-xml.sf.net/technical/1.html" style="text-decoration: none">1. Introduction</a></font></b></p>
      <p><b><font face="Tahoma" size="1">&nbsp; 2. A Processing Model Based on VTD</font></b></p>
      <p><b><font face="Tahoma" size="1">&nbsp;
      <a href="http://vtd-xml.sf.net/technical/3.html" style="text-decoration: none">3. Navigate XML</a></font></b></p>
      <p><b><font face="Tahoma" size="1">&nbsp;
      <a href="http://vtd-xml.sf.net/technical/4.html" style="text-decoration: none">4. A Closer Look</a></font></b></p>
      <p><b><font face="Tahoma" size="1">&nbsp;
      <a href="http://vtd-xml.sf.net/technical/5.html" style="text-decoration: none">5. Conclusion</a></font></b></p>
      <p><b><font face="Tahoma" size="1">&nbsp;
      <a href="http://vtd-xml.sf.net/technical/6.html" style="text-decoration: none">References</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="11" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/codeSample/cs1.html" style="text-decoration: none">Code Samples</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="3" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/faq.html" style="text-decoration: none">FAQ</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="2" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/involved.html" style="text-decoration: none">
      Getting Involved</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="5" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/links.html" style="text-decoration: none">Articles and Presentations</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="18" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a style="text-decoration: none" href="http://vtd-xml.sourceforge.net/benchmark1.html">Benchmark</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="32" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/javadoc/" style="text-decoration: none">API Doc</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="19" align="left" bordercolor="#0000FF" valign="top">
    <blockquote>
      <p><b><font face="Tahoma" size="1">
      <a href="http://vtd-xml.sf.net/demo/demo1.html" style="text-decoration: none">Demo</a></font></b></p>
    </blockquote>
    </td>
  </tr>
  <tr>
    <td width="259" height="3606" bordercolor="#0000FF">&nbsp;</td>
  </tr>
</table>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5147731-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
</body>
</html>